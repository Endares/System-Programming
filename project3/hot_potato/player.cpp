#include <iostream>
#include <string>
#include <cstring>
#include <cstdlib>
#include <unistd.h>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <cassert>
#include "potato.hpp"
#include "player.hpp"
#include "network.hpp"

/** player_listen_fd must be reference here. so that it can pass the value 
 *  generated by init() to main()
 */
void connect_server(int player_fd, int& player_listen_fd, int& player_id, int& num_players) {
    MetaInfo meta;
    recv(player_fd, &player_id, sizeof(player_id), 0);
    recv(player_fd, &num_players, sizeof(num_players), 0);
    std::cout << "Connected as player " << player_id << " out of " << num_players << " total players" << std::endl;
    // send port number of player's listen socket!!! to ringmaster
    // this is used for other players to connect to this player
    // passing an empty string ("") or NULL as the service/port tells the system to use an ephemeral port
    player_listen_fd = init_server("");
    int player_listen_port = get_port(player_listen_fd);
    send(player_fd, &player_listen_port, sizeof(player_listen_port), 0);
}

void neighbor_test(int left_fd, int right_fd, int player_id) {
    int left_id, right_id;
    // connection test to left neighbor
    send(right_fd, &player_id, sizeof(player_id), 0); // send message to my right
    recv(left_fd, &left_id, sizeof(left_id), 0); // my left send me message
    // connection test to left neighbor
    send(left_fd, &player_id, sizeof(player_id), 0);
    recv(right_fd, &right_id, sizeof(right_id), 0);
    cout << "left neighbor id: " << left_id << "; right neighbor id: " << right_id << endl;
}

/**
 * Establish TCP connection with left neighbor
 */
void connect_neighbor(int player_fd, int listen_fd, int& left_fd, int& right_fd, int player_id) {
    MetaInfo meta;
    // receive right neighbor info from ring master
    recv(player_fd, &meta, sizeof(meta), 0);
    // cout << "Neighbor Info: port: " << meta.port << "   ip:" << meta.ip << endl;

    right_fd = init_client(meta.ip, to_string(meta.port).c_str());
    // cout << "Connect to right neighbor." << endl;

    // accept() connection from left player
    string left_ip;
    left_fd = accept_connection(listen_fd, left_ip);
    // cout << "Connection established with left player ip: "  << left_ip << endl;
    // neighbor_test(left_fd, right_fd, player_id);
}

/**
 * Randomly toss potato to left / right player
 */
void toss_potato(Potato& p, int socket_fd, int neigbor_id) {
    send(socket_fd, &p, sizeof(p), 0);
    std::cout << "Sending potato to " << neigbor_id << std::endl;
}

/**
 * Inform ringmaster end of the game when remainHops == 0
 * and annouce "I'm it"
 */
void report_end(Potato& p, int player_fd, const char* announcement) {
    send(player_fd, &p, sizeof(p), 0);
    cout << announcement << endl;
}

/**
 * Deal with potato:
 * 1. Add current player_id to path
 * 2. Randomly toss potato to left / right player
 * 3. Decrease remainingHops, if = 0, inform ringmaster
 */
void deal_with_potato(Potato& p, int player_fd, int left_fd, int right_fd, int player_id, int num_players) {
    assert(p.remainHops > 0);
    --p.remainHops; // need to do decrease before toss, so as to give neighbor the right value
    p.addToPath(player_id);
    // p.printPath();
    if (p.remainHops == 0) {
        report_end(p, player_fd, "I'm it");
        return;
    }
    
    int random = rand() % 2;
    if (random == 0) {
        toss_potato(p, left_fd, (player_id - 1 + num_players) % num_players);
    } else {
        toss_potato(p, right_fd, (player_id + 1) % num_players);
    }
}

/** 
 * Potato can be received from: 
 * 1.ring master (through player_fd);
 * 2.left neighbor (through left_fd);
 * 3.right neighbor (through right_fd).
 * Player'll be looping to listen for these msgs until master send the end signal
 * Player'll need to send end msg to master when remainHop = 0.
 * select() prototype: int select(int n, fd_set *readfds, fd_set *writefds, 
 *                     fd_set *exceptfds, struct timeval *timeout);
 */
void receive_potato(int player_fd, int left_fd, int right_fd, int player_id, int num_players) {
    Potato potato;
    // recv(player_fd, &potato, sizeof(potato), 0);

    int max_fd = max(player_fd, max(left_fd, right_fd));
    while (true) {
        // select(): check player_fd, left_fd, right_fd at the same time
        fd_set readfds;
        // clear set every loop and re-initialize it
        FD_ZERO(&readfds);
        // add fds to set
        FD_SET(player_fd, &readfds);
        FD_SET(left_fd, &readfds);
        FD_SET(right_fd, &readfds);     
        int status = select(max_fd + 1, &readfds, NULL, NULL, NULL);
        int has_msg = 0;
        if (status == -1) {
           perror("select"); 
           exit(EXIT_FAILURE);
        } else if (status == 0) {
            cout << "Timeout occurred! No data has received!" << endl;
        } else { // at least one recv()
        // can only handle one recv() at a time
            if (FD_ISSET(left_fd, &readfds)) {
                has_msg = recv(left_fd, &potato, sizeof(potato), MSG_WAITALL);
                // cout << "Recieving the potato from left neighbor." << endl;
            } else if (FD_ISSET(right_fd, &readfds)) {
                has_msg = recv(right_fd, &potato, sizeof(potato), MSG_WAITALL);
                // cout << "Recieving the potato from right neighbor." << endl;
            } else if (FD_ISSET(player_fd, &readfds)) {
                has_msg = recv(player_fd, &potato, sizeof(potato), MSG_WAITALL);
                // cout << "Recieving the potato from master." << endl;
            }
            if (has_msg == -1) {
                perror("receive");
                exit(EXIT_FAILURE);
            } else if (has_msg == 0) { // the remote side has closed the connection
                // cout << "Connection closed. Exiting loop." << endl;
                // cout << "End of the game!" << endl;
                break;
            } else if (potato.remainHops == 0) { // receive ending signal
                // cout << "End of the game!" << endl;
                break;
            } else {
                deal_with_potato(potato, player_fd, left_fd, right_fd, player_id, num_players);
            }
        }
    }
}

/**
 * Close listen_fd, left_fd, right_fd
 */
void close_player(int left_fd, int right_fd, int listen_fd) {
    close(left_fd);
    close(right_fd);
    close(listen_fd);
}

/**
 * 1. Establish TCP connection with ringmaster
 * 2. Recieve player info from ringmaster
 * 3. Receive neighbor info from ringmaster and establish p2p connection to neighbor
 * 4. Play the game
 * 5. Close socket to end the connection
 */
int main(int argc, char *argv[]) {
    if (argc != 3) {
        cerr << "Usage: " << argv[0] << " <machine_name> <port_num>" << endl;
        exit(EXIT_FAILURE);
    }

    const char* hostname = argv[1]; // ringmaster's hostname
    const char* port_name = argv[2];     // ringmaster's port number

    // 1. Establish a TCP connection to the ringmaster
    int player_fd = init_client(hostname, port_name);
    // 2. Generate listen socket and send listen port to ringmaster
    int player_listen_fd;
    int player_id, num_players;
    connect_server(player_fd, player_listen_fd, player_id, num_players);
    // 3. Connect to neighbors
    int left_fd, right_fd; // fd of TCP connection to left, right neighbor
    connect_neighbor(player_fd, player_listen_fd, left_fd, right_fd, player_id);
    // 4. Play the game
    receive_potato(player_fd, left_fd, right_fd, player_id, num_players);
    // 5. Close player's fd: listen_fd, left_fd, right_fd 
    // (fd to ringmaster will be closed by ringmaster)
    close_player(left_fd, right_fd, player_listen_fd);
    
    return EXIT_SUCCESS;
}